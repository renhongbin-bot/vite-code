// src/generator.ts
import { normalizePath as normalizePath4 } from "vite";

// src/utils.ts
import consola from "consola";
import fs from "node:fs/promises";
import { normalizePath } from "vite";

// src/constants.ts
var MODULE_NAME = "vite-aliases";
var config = {
  dir: "src",
  prefix: "@",
  deep: true,
  depth: 1,
  createGlobalAlias: true,
  createLog: false,
  logPath: "src/logs",
  adjustDuplicates: false,
  useAbsolute: false,
  useConfig: false,
  useIndexes: false,
  useTypescript: false,
  root: process.cwd()
};
var IDEConfig = {
  compilerOptions: {
    baseUrl: ".",
    paths: {}
  }
};

// src/utils.ts
import { parse, stringify } from "comment-json";
function split(string, seperator) {
  return string.split(seperator);
}
function toArray(value) {
  if (Array.isArray(value)) {
    return value;
  } else {
    return [value];
  }
}
function toRelative(path, dir) {
  let folders = split(normalizePath(path), "/");
  folders = folders.slice(
    folders.findIndex((f) => f === dir),
    folders.length
  );
  return normalizePath(`./${folders.join("/")}`);
}
function toCamelCase(string) {
  return string.trim().replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : "");
}
var logger = consola.create({ defaults: { message: `[${MODULE_NAME}] -` } });
function abort(message) {
  throw logger.error(new Error(message));
}
async function readJSON(path) {
  try {
    const file = (await fs.readFile(path, "utf-8")).toString();
    logger.success(`Config: ${path} successfully read!`);
    return parse(file);
  } catch (error) {
    logger.error(`File: ${path} was not found!`);
  }
}
async function writeJSON(path, data, process2) {
  const name = path.replace(/^.*[\\\/]/, "");
  const state = process2 === "add" || process2 === "default" ? "created" : "updated";
  try {
    await fs.writeFile(path, stringify(data, null, 4));
    logger.success(`File: ${name} successfully ${state}`);
  } catch (error) {
    logger.error(`File: ${name} could not be ${state}.`);
    abort(error);
  }
}

// src/fs/config.ts
import { normalizePath as normalizePath2 } from "vite";
async function writeConfig(gen, process2 = "default") {
  const { root, dir, useTypescript, useConfig } = gen.options;
  if (!useConfig) {
    return;
  }
  const name = useTypescript ? "tsconfig" : "jsconfig";
  const file = normalizePath2(`${root}/${name}.json`);
  try {
    let json = await readJSON(file);
    if (!json) {
      IDEConfig.compilerOptions.paths = { ...gen.paths };
      json = Object.assign({}, IDEConfig);
    }
    if (!json.compilerOptions) {
      json.compilerOptions = {
        paths: { ...gen.paths }
      };
    }
    let paths = json.compilerOptions.paths || {};
    if (process2 === "remove") {
      paths = Object.fromEntries(
        Object.entries(paths).filter((p) => {
          if (Object.values(gen.paths).flat().includes(p[1][0]) && p[1][0].includes(dir)) {
            return p;
          } else if (!p[1][0].includes(dir)) {
            return p;
          }
        })
      );
    }
    json.compilerOptions.paths = { ...paths, ...gen.paths };
    await writeJSON(file, json, process2);
  } catch (error) {
    abort(`Cannot write Config: ${file}.`);
  }
}

// src/fs/glob.ts
import fg from "fast-glob";
async function getDirectories(gen) {
  const { dir, root, deep, depth } = gen.options;
  const directories = await fg.sync(deep ? `${dir}/**/*` : `${dir}/*`, {
    ignore: ["node_modules"],
    onlyDirectories: true,
    cwd: root,
    deep: depth,
    absolute: true
  });
  if (!directories.length) {
    logger.error(new Error("No Directories could be found!"));
  }
  gen.addAlias(directories);
}

// src/fs/log.ts
import { existsSync } from "node:fs";
import { mkdir } from "node:fs/promises";
import { normalizePath as normalizePath3 } from "vite";
async function writeLog(gen, process2 = "normal") {
  const { dir, createLog, logPath } = gen.options;
  if (!createLog) {
    return;
  }
  const folder = normalizePath3(logPath);
  const file = normalizePath3(`${folder}/${MODULE_NAME}.json`);
  const data = gen.aliases;
  try {
    if (!existsSync(folder)) {
      await mkdir(folder, { recursive: true });
    }
    await writeJSON(file, data, process2);
  } catch (error) {
    abort(`Cannot create Logfolder ${folder}.`);
  }
}

// src/generator.ts
import chokidar from "chokidar";
import { resolve } from "path";
var Generator = class {
  constructor(servermode, options) {
    this.servermode = servermode;
    this.options = Object.assign({}, config, options);
    this.fullPath = normalizePath4(resolve(this.options.root, this.options.dir));
    if (servermode === "serve") {
      this.observe();
    }
  }
  options;
  fullPath;
  aliases = [];
  directories = /* @__PURE__ */ new Set();
  paths = {};
  addAlias(path) {
    toArray(path).forEach((p) => {
      const correctedPath = normalizePath4(p);
      const folders = split(correctedPath.replace(this.fullPath, this.options.dir), "/").filter(Boolean);
      const lastDir = folders.slice(-1)[0];
      let key = `${this.options.prefix}${lastDir}`;
      const uniqueFolders = [...new Set(folders)];
      this.checkForDuplicates(correctedPath, folders, uniqueFolders);
      if (this.aliases.some((a) => a.find === key)) {
        logger.warn(
          "There are duplicate Aliases generated, either fix the folderstructure or enable adjustDuplicates."
        );
        if (this.options.adjustDuplicates && this.options.depth > 1) {
          const name = folders.filter((f) => !split(normalizePath4(this.options.dir), "/").includes(f)).join("-");
          key = `${this.options.prefix}${toCamelCase(name)}`;
        }
      }
      if (lastDir === this.options.dir && this.options.createGlobalAlias) {
        key = `${this.options.prefix}`;
      }
      this.directories.add(p);
      this.aliases.push({
        find: `${key}`,
        replacement: `${p}`
      });
      const configPath = this.options.useAbsolute ? correctedPath : toRelative(correctedPath, this.options.dir);
      if (this.options.useIndexes) {
        this.paths[key] = [configPath];
      } else {
        this.paths[`${key}/*`] = [`${configPath}/*`];
      }
    });
  }
  removeAlias(path) {
    toArray(path).forEach((p) => {
      const correctedPath = normalizePath4(p);
      if (this.directories.has(correctedPath)) {
        this.directories.delete(correctedPath);
        this.aliases = this.aliases.filter((a) => a.replacement != correctedPath);
        this.paths = Object.fromEntries(
          Object.entries(this.paths).filter(
            (configPath) => configPath[1][0].slice(0, -2) != (this.options.useIndexes ? correctedPath : `${correctedPath}/*`)
          )
        );
      }
    });
  }
  checkForDuplicates(initialPath, folders, uniqueFolders) {
    if (folders.length !== uniqueFolders.length) {
      const duplicateFolders = [...folders].sort().filter((f, i, self) => {
        if (self[i + 1] === self[i]) {
          return f;
        }
      });
      logger.warn(`Path: '${initialPath}' contains multiple folders with same name: ${duplicateFolders.toString()}.`);
    }
  }
  searched = false;
  async init() {
    if (this.searched) {
      return;
    }
    await getDirectories(this);
    if (this.options.createGlobalAlias) {
      this.addAlias(this.fullPath);
    }
    writeLog(this);
    writeConfig(this);
    this.searched = true;
  }
  observe() {
    const watcher = chokidar.watch(this.fullPath, { ignoreInitial: true, depth: this.options.depth });
    watcher.on("addDir", (path) => {
      this.addAlias(path);
      writeLog(this, "add");
      writeConfig(this, "add");
      logger.info(`Watcher added new Path: ${path}`);
    }).on("unlinkDir", (path) => {
      this.removeAlias(path);
      writeLog(this, "remove");
      writeConfig(this, "remove");
      logger.info(`Watcher removed Path: ${path}`);
    });
  }
};

// src/index.ts
function ViteAliases(options = {}) {
  let gen;
  return {
    name: "vite-aliases",
    enforce: "pre",
    config(config2, { command }) {
      var _a;
      gen = new Generator(command, options);
      gen.init();
      config2.resolve = {
        alias: ((_a = config2.resolve) == null ? void 0 : _a.alias) ? [...toArray(config2.resolve.alias), ...gen.aliases] : gen.aliases
      };
    }
  };
}
export {
  ViteAliases
};
//# sourceMappingURL=index.js.map